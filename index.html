<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Webglsurfer by johannes-riesterer</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Webglsurfer</h1>
        <h2>Port of SURFER to WebGL</h2>
        <a href="https://github.com/johannes-riesterer/WebGLSurfer" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <p>&lt;!DOCTYPE html&gt;

    </p>
        three.js canvas - particles - waves
               body {
                  background-color: #ffffff;
                  margin: 0px;
                  overflow: hidden;
               }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        a {
           color:#0078ff;
        }
        &amp;lt;/style&amp;gt;
        &amp;lt;/head&amp;gt;
      &amp;lt;div id=&amp;quot;canvas&amp;quot;&amp;gt; &amp;lt;/div&amp;gt;
&amp;lt;body&amp;gt;

  &amp;lt;script src=&amp;quot;three.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&amp;quot;stats.min.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;

  &amp;lt;script src =&amp;quot;aShader.js&amp;quot; type=&amp;quot;x-shader/x-fragment&amp;quot; id=&amp;quot;fragmentshader&amp;quot;&amp;gt;

     uniform vec3      iResolution;           // viewport resolution (in pixels)
     uniform float     iGlobalTime;           // shader playback time (in seconds)
     uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)
     uniform samplerCube iChannel0;
     uniform sampler2D iChannel1;
     uniform samplerCube iChannel2;
     uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click
     uniform vec4      iDate;                 // (year, month, day, time in seconds)

     float precis = 0.001;



        //==================================================================================
        // some dual real numbers functions, for f : R3 -&amp;gt; R1

        struct dualR3
        {
           float x, y, z;
           float dx, dy, dz;
        };

  vec4 dSet( float a ) { return vec4( a, 0.0, 0.0, 0.0 ); }
  vec4 getX( dualR3 n ) {   return vec4(n.x, n.dx, 0.0, 0.0 ); }
  vec4 getY( dualR3 n ) {   return vec4(n.y, 0.0, n.dy, 0.0 ); }
  vec4 getZ( dualR3 n ) {   return vec4(n.z, 0.0, 0.0, n.dz ); }

  vec4 dSqrX( dualR3 a ) { return vec4( a.x*a.x, 2.0*a.x*a.dx, 0.0, 0.0 ); }
  vec4 dSqrY( dualR3 a ) { return vec4( a.y*a.y, 0.0, 2.0*a.y*a.dy, 0.0 ); }
  vec4 dSqrZ( dualR3 a ) { return vec4( a.z*a.z, 0.0, 0.0, 2.0*a.z*a.dz ); }

  vec4 dMul( vec4 a, vec4 b ) { return vec4( a.x*b.x, a.y*b.x + a.x*b.y, a.z*b.x + a.x*b.z, a.w*b.x + a.x*b.w );

  }



     //===========================================================================================
     // dual-numbers way: compute gradients (and distance estimation) analytically
     //===========================================================================================

     vec4 func( dualR3 p )
     {
           // f(x,y,z) = z² - (y²-3x²)·(3y²-x²)·(1-x)
           return dSqrZ(p) - dMul( dMul( dSqrY(p) - 3.0*dSqrX(p), 3.0*dSqrY(p) - dSqrX(p)), dSet(1.0) - getX(p) );
           //             return dSqrX(p) + dSqrY(p) + dSqrZ(p) + 2.0 * dMul(dMul(getX(p), getY(p)), getZ(p)) - dSet(1.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;//return dMul(dMul(dSqrX(p), dSqrX(p)), dSqrX(p)) + dMul(dMul(dSqrY(p), dSqrY(p)), dSqrY(p)) + dMul(dMul(dSqrZ(p), dSqrZ(p)), dSqrZ(p))- dSet(1.0);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     }

  vec3 grad( in vec3 p )
  {
     return func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) ).yzw;
  }

  float dist( vec3 p )
  {
     vec4 f = func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) );
     return abs(f.x) / length(f.yzw);
  }

  float map( vec3 p )
  {
     return func( dualR3(p.x,p.y,p.z,0.0,0.0,0.0) ).x;
  }


     //==================================================================================


     vec2 intersect( in vec3 ro, in vec3 rd )
     {
        float mind = 0.001;
        float maxd = 20.0;


        {
           float b = dot(ro,rd);
           float c =1.5;   //zoom ?!?
           float h = b*b - c;
           if( h&amp;lt;0.0 ) return vec2(-1.0,0.0);
           h = sqrt(h);
              mind = max( mind, -b - h );
              maxd = min( maxd, -b + h );
        }

        float h = 1.0;
        float t = mind;
        for( int i=0; i&amp;lt;300; i++ )
        {
           if( h&amp;lt;precis||t&amp;gt;maxd ) continue;
           h = dist( ro+rd*t );
           t += min(15.0*precis,h);
        }

        if( t&amp;gt;maxd ) t=-1.0;

        return vec2(t,sign(h));
     }

  vec3 calcNormal( in vec3 p )
  {
     return normalize( grad(p) );
  }

  void main(void)
  {
     float time = iGlobalTime;

     vec3 lightPos = vec3(0.0,15.0,0.0);
     vec3 lightPos2 = vec3(0.0,-15.0,0.0);

     vec3 specColor = vec3(0.3, 1.0,  1.0);
     vec3 diffuseColor = 0.8*specColor;


     vec2 q = gl_FragCoord.xy / iResolution.xy;
     vec2 m = vec2(0.5);

        // animation

        vec3 tot = vec3(0.0);

        vec2 p = -vec2(1.0, 1.0)+ (gl_FragCoord.xy )/iResolution.xy;
           //   p.x *= iResolution.x/iResolution.y;

              // camera
              vec3 ro = 2.5*vec3(sin(0.5*time),0.0,cos(0.5*time));
              vec3 ta = vec3( 0.0, 0.0, 0.0 );
              vec3 ww = normalize( ta - ro );
              vec3 uu = normalize( cross(ww,vec3(0.0,1.,0.0) ) );
              vec3 vv = normalize( cross(uu,ww));
              vec3 rd = normalize( p.x*uu + p.y*vv + 0.5*ww );

                 // raymarch
                 vec2 t = intersect(ro,rd);

                    // shade
                    vec3 col = vec3(0.0);
                    if( t.x&amp;gt;0.0 )
                    {
                          // geometry
                          vec3 pos = ro + t.x*rd;
                          vec3 normal = calcNormal(pos);

                             //shading
                             vec3 lightDir = normalize(lightPos - pos);
                             vec3 lightDir2 = normalize(lightPos2 - pos);

                             float lambertian = max(dot(lightDir,normal), 0.0);
                             float specular = 0.0;

                             float lambertian2 = max(dot(lightDir2,normal), 0.0);
                             float specular2 = 0.0;

                             vec3 viewDir = normalize(-pos);

                             if(lambertian &amp;gt; 0.0) {

                                vec3 reflectDir = reflect(-lightDir, normal);




                               float specAngle = max(dot(reflectDir, viewDir), 0.0);

                                   // the exponent controls the shininess (try mode 2)
                                   //if(mode == 2)  specular = pow(specAngle, 16.0);

                                      // according to the rendering equation we would need to multiply
                                      // with the the &amp;quot;lambertian&amp;quot;, but this has little visual effect
                                       specular *= lambertian;
                                      //specular = pow(specAngle, 10.0);
                                         // switch to mode 4 to turn off the specular component


                             }


                             if(lambertian2 &amp;gt; 0.0) {

                                vec3 reflectDir2 = reflect(-lightDir2, normal);




                                float specAngle2 = max(dot(reflectDir2, viewDir), 0.0);

                                   // the exponent controls the shininess (try mode 2)
                                   //if(mode == 2)  specular = pow(specAngle, 16.0);

                                      // according to the rendering equation we would need to multiply
                                      // with the the &amp;quot;lambertian&amp;quot;, but this has little visual effect
                                      specular2 *= lambertian2;
                                         //specular = pow(specAngle, 10.0);
                                         // switch to mode 4 to turn off the specular component


                             }


                             col = vec3( (lambertian + lambertian2)*diffuseColor +
                                        (specular+ specular2)*specColor);
                    }

                    else
                    {
                          // background
                          col =vec3(1.0,1.0,1.0);
                    }



                    gl_FragColor = vec4( col, 1.0 );
  }



  &amp;lt;/script&amp;gt;


  &amp;lt;script type=&amp;quot;x-shader/x-vertex&amp;quot; id=&amp;quot;vertexshader&amp;quot;&amp;gt;
     void main() {
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
  &amp;lt;/script&amp;gt;


    &amp;lt;script&amp;gt;

     var container;
        var camera, scene, renderer;


     var uniforms;
     var attributes;
     var shaderMaterials = new Array();
     var cube;

     var geometry;
     var stats;




        init();
        animate();

        function init() {

           //init scene and camera
        container = document.getElementById( &amp;#39;canvas&amp;#39; );



        camera = new THREE.PerspectiveCamera( 5, window.innerWidth / window.innerHeight, 10, 8000 );
        camera.position.z =  200;

        camera.lookAt(new THREE.Vector3(0,0,0));

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog( 0x555555, 2000, 3500 );

        uniforms = {
                iResolution: {  type: &amp;#39;v3&amp;#39;, value: new THREE.Vector3( 300.0, 300.0, 1.0 )  },
                iGlobalTime: {  type: &amp;#39;f&amp;#39;, value: 1.0 },
                iChannelResolution: {   type: &amp;#39;v3&amp;#39;, value: new THREE.Vector3( 100.0, 100.0, 100.0 )   },
                iMouse: {   type: &amp;#39;v3&amp;#39;, value: new THREE.Vector3( 0.0, 1.0, 2.0 )},
                iDate:  {   type: &amp;#39;v4&amp;#39;, value: new THREE.Vector4( 0.0, 1.0, 2.0, 2.0 )  },
                iChannel0: {type: &amp;#39;t&amp;#39;, value: THREE.ImageUtils.loadTexture( &amp;quot;aTexture.png&amp;quot; ) },
                iChannel1: {type: &amp;#39;t&amp;#39;, value: THREE.ImageUtils.loadTexture( &amp;quot;aTexture.png&amp;quot; ) },
                iChannel2: {type: &amp;#39;t&amp;#39;, value: THREE.ImageUtils.loadTexture( &amp;quot;aTexture.png&amp;quot; ) }
                };


        var material = new THREE.ShaderMaterial( {
                                                uniforms: uniforms,
                                                vertexShader:   document.getElementById( &amp;#39;vertexshader&amp;#39; ).textContent,
                                                fragmentShader: document.getElementById( &amp;#39;fragmentshader&amp;#39; ).textContent
        });




        geometry = new THREE.PlaneGeometry(45, 45);
        cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );
        renderer.setClearColor( scene.fog.color, 1 );
        renderer.setSize( 800, 600);

        container.appendChild( renderer.domElement );
        stats = new Stats();
            stats.domElement.style.position = &amp;#39;absolute&amp;#39;;
            stats.domElement.style.top = &amp;#39;0px&amp;#39;;
            container.appendChild( stats.domElement );


  }

  function onWindowResize() {

     windowHalfX = window.innerWidth / 2;
     windowHalfY = window.innerHeight / 2;

     camera.aspect = window.innerWidth / window.innerHeight;
     camera.updateProjectionMatrix();

     renderer.setSize( window.innerWidth, window.innerHeight );

  }

        //

  function animate() {
     requestAnimationFrame( animate );
  uniforms.iGlobalTime.value += 0.03;
        uniforms.iGlobalTime.needsUpdate = true;
     renderer.render( scene, camera );
     stats.update();

  }

     &amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/html&gt;&lt;/p&gt;
        </section>

        <aside id="sidebar">
          <a href="https://github.com/johannes-riesterer/WebGLSurfer/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/johannes-riesterer/WebGLSurfer/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/johannes-riesterer/WebGLSurfer"></a> is maintained by <a href="https://github.com/johannes-riesterer">johannes-riesterer</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>