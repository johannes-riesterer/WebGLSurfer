{"name":"Webglsurfer","tagline":"Port of SURFER to WebGL","body":"<!DOCTYPE html>\r\n<html lang=\"en\">\r\n\t<head>\r\n\t\t<title>three.js canvas - particles - waves</title>\r\n\t\t<meta charset=\"utf-8\">\r\n         <meta name=\"viewport\" content=\"width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0\">\r\n            <style>\r\n               body {\r\n                  background-color: #ffffff;\r\n                  margin: 0px;\r\n                  overflow: hidden;\r\n               }\r\n            \r\n            a {\r\n               color:#0078ff;\r\n            }\r\n            </style>\r\n            </head>\r\n          <div id=\"canvas\"> </div>\r\n\t<body>\r\n\r\n      <script src=\"three.js\"></script>\r\n      <script src=\"stats.min.js\"></script>\r\n      \r\n      <script src =\"aShader.js\" type=\"x-shader/x-fragment\" id=\"fragmentshader\">\r\n         \r\n         uniform vec3      iResolution;           // viewport resolution (in pixels)\r\n         uniform float     iGlobalTime;           // shader playback time (in seconds)\r\n         uniform vec3      iChannelResolution[4]; // channel resolution (in pixels)\r\n         uniform samplerCube iChannel0;\r\n         uniform sampler2D iChannel1;\r\n         uniform samplerCube iChannel2;\r\n         uniform vec4      iMouse;                // mouse pixel coords. xy: current (if MLB down), zw: click\r\n         uniform vec4      iDate;                 // (year, month, day, time in seconds)\r\n         \r\n         float precis = 0.001;\r\n\r\n\r\n         \r\n            //==================================================================================\r\n            // some dual real numbers functions, for f : R3 -> R1\r\n            \r\n            struct dualR3\r\n            {\r\n               float x, y, z;\r\n               float dx, dy, dz;\r\n            };\r\n      \r\n      vec4 dSet( float a ) { return vec4( a, 0.0, 0.0, 0.0 ); }\r\n      vec4 getX( dualR3 n ) {\treturn vec4(n.x, n.dx, 0.0, 0.0 ); }\r\n      vec4 getY( dualR3 n ) {\treturn vec4(n.y, 0.0, n.dy, 0.0 ); }\r\n      vec4 getZ( dualR3 n ) {\treturn vec4(n.z, 0.0, 0.0, n.dz ); }\r\n      \r\n      vec4 dSqrX( dualR3 a ) { return vec4( a.x*a.x, 2.0*a.x*a.dx, 0.0, 0.0 ); }\r\n      vec4 dSqrY( dualR3 a ) { return vec4( a.y*a.y, 0.0, 2.0*a.y*a.dy, 0.0 ); }\r\n      vec4 dSqrZ( dualR3 a ) { return vec4( a.z*a.z, 0.0, 0.0, 2.0*a.z*a.dz ); }\r\n      \r\n      vec4 dMul( vec4 a, vec4 b ) { return vec4( a.x*b.x, a.y*b.x + a.x*b.y, a.z*b.x + a.x*b.z, a.w*b.x + a.x*b.w );\r\n         \r\n      }\r\n      \r\n      \r\n      \r\n         //===========================================================================================\r\n         // dual-numbers way: compute gradients (and distance estimation) analytically\r\n         //===========================================================================================\r\n         \r\n         vec4 func( dualR3 p )\r\n         {\r\n               // f(x,y,z) = z² - (y²-3x²)·(3y²-x²)·(1-x)\r\n               return dSqrZ(p) - dMul( dMul( dSqrY(p) - 3.0*dSqrX(p), 3.0*dSqrY(p) - dSqrX(p)), dSet(1.0) - getX(p) );\r\n               //             return dSqrX(p) + dSqrY(p) + dSqrZ(p) + 2.0 * dMul(dMul(getX(p), getY(p)), getZ(p)) - dSet(1.0);\r\n\r\n   //return dMul(dMul(dSqrX(p), dSqrX(p)), dSqrX(p)) + dMul(dMul(dSqrY(p), dSqrY(p)), dSqrY(p)) + dMul(dMul(dSqrZ(p), dSqrZ(p)), dSqrZ(p))- dSet(1.0);\r\n\r\n\r\n         }\r\n      \r\n      vec3 grad( in vec3 p )\r\n      {\r\n         return func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) ).yzw;\r\n      }\r\n      \r\n      float dist( vec3 p )\r\n      {\r\n         vec4 f = func( dualR3(p.x,p.y,p.z,1.0,1.0,1.0) );\r\n         return abs(f.x) / length(f.yzw);\r\n      }\r\n      \r\n      float map( vec3 p )\r\n      {\r\n         return func( dualR3(p.x,p.y,p.z,0.0,0.0,0.0) ).x;\r\n      }\r\n      \r\n      \r\n         //==================================================================================\r\n         \r\n         \r\n         vec2 intersect( in vec3 ro, in vec3 rd )\r\n         {\r\n            float mind = 0.001;\r\n            float maxd = 20.0;\r\n            \r\n            \r\n            {\r\n               float b = dot(ro,rd);\r\n               float c =1.5;   //zoom ?!?\r\n               float h = b*b - c;\r\n               if( h<0.0 ) return vec2(-1.0,0.0);\r\n               h = sqrt(h);\r\n                  mind = max( mind, -b - h );\r\n                  maxd = min( maxd, -b + h );\r\n            }\r\n            \r\n            float h = 1.0;\r\n            float t = mind;\r\n            for( int i=0; i<300; i++ )\r\n            {\r\n               if( h<precis||t>maxd ) continue;\r\n               h = dist( ro+rd*t );\r\n               t += min(15.0*precis,h);\r\n            }\r\n            \r\n            if( t>maxd ) t=-1.0;\r\n            \r\n            return vec2(t,sign(h));\r\n         }\r\n      \r\n      vec3 calcNormal( in vec3 p )\r\n      {\r\n         return normalize( grad(p) );\r\n      }\r\n      \r\n      void main(void)\r\n      {\r\n         float time = iGlobalTime;\r\n\r\n         vec3 lightPos = vec3(0.0,15.0,0.0);\r\n         vec3 lightPos2 = vec3(0.0,-15.0,0.0);\r\n         \r\n         vec3 specColor = vec3(0.3, 1.0,  1.0);\r\n         vec3 diffuseColor = 0.8*specColor;\r\n         \r\n\r\n         vec2 q = gl_FragCoord.xy / iResolution.xy;\r\n         vec2 m = vec2(0.5);\r\n         \r\n            // animation\r\n            \r\n            vec3 tot = vec3(0.0);\r\n            \r\n            vec2 p = -vec2(1.0, 1.0)+ (gl_FragCoord.xy )/iResolution.xy;\r\n               //   p.x *= iResolution.x/iResolution.y;\r\n               \r\n                  // camera\r\n                  vec3 ro = 2.5*vec3(sin(0.5*time),0.0,cos(0.5*time));\r\n                  vec3 ta = vec3( 0.0, 0.0, 0.0 );\r\n                  vec3 ww = normalize( ta - ro );\r\n                  vec3 uu = normalize( cross(ww,vec3(0.0,1.,0.0) ) );\r\n                  vec3 vv = normalize( cross(uu,ww));\r\n                  vec3 rd = normalize( p.x*uu + p.y*vv + 0.5*ww );\r\n                  \r\n                     // raymarch\r\n                     vec2 t = intersect(ro,rd);\r\n                     \r\n                        // shade\r\n                        vec3 col = vec3(0.0);\r\n                        if( t.x>0.0 )\r\n                        {\r\n                              // geometry\r\n                              vec3 pos = ro + t.x*rd;\r\n                              vec3 normal = calcNormal(pos);\r\n                              \r\n                                 //shading\r\n                                 vec3 lightDir = normalize(lightPos - pos);\r\n                                 vec3 lightDir2 = normalize(lightPos2 - pos);\r\n                                 \r\n                                 float lambertian = max(dot(lightDir,normal), 0.0);\r\n                                 float specular = 0.0;\r\n                                 \r\n                                 float lambertian2 = max(dot(lightDir2,normal), 0.0);\r\n                                 float specular2 = 0.0;\r\n                                 \r\n                                 vec3 viewDir = normalize(-pos);\r\n\r\n                                 if(lambertian > 0.0) {\r\n                                    \r\n                                    vec3 reflectDir = reflect(-lightDir, normal);\r\n                                    \r\n                                   \r\n                                   \r\n                                   \r\n                                   float specAngle = max(dot(reflectDir, viewDir), 0.0);\r\n                                    \r\n                                       // the exponent controls the shininess (try mode 2)\r\n                                       //if(mode == 2)  specular = pow(specAngle, 16.0);\r\n                                       \r\n                                          // according to the rendering equation we would need to multiply\r\n                                          // with the the \"lambertian\", but this has little visual effect\r\n                                           specular *= lambertian;\r\n                                          //specular = pow(specAngle, 10.0);\r\n                                             // switch to mode 4 to turn off the specular component\r\n                                             \r\n                                             \r\n                                 }\r\n                                 \r\n                                 \r\n                                 if(lambertian2 > 0.0) {\r\n                                    \r\n                                    vec3 reflectDir2 = reflect(-lightDir2, normal);\r\n                                    \r\n                                    \r\n                                    \r\n                                    \r\n                                    float specAngle2 = max(dot(reflectDir2, viewDir), 0.0);\r\n                                    \r\n                                       // the exponent controls the shininess (try mode 2)\r\n                                       //if(mode == 2)  specular = pow(specAngle, 16.0);\r\n                                       \r\n                                          // according to the rendering equation we would need to multiply\r\n                                          // with the the \"lambertian\", but this has little visual effect\r\n                                          specular2 *= lambertian2;\r\n                                             //specular = pow(specAngle, 10.0);\r\n                                             // switch to mode 4 to turn off the specular component\r\n                                             \r\n                                             \r\n                                 }\r\n                                 \r\n                                 \r\n                                 col = vec3( (lambertian + lambertian2)*diffuseColor +\r\n                                            (specular+ specular2)*specColor);\r\n                        }\r\n                        \r\n                        else\r\n                        {\r\n                              // background\r\n                              col =vec3(1.0,1.0,1.0);\r\n                        }\r\n                        \r\n                        \r\n                        \r\n                        gl_FragColor = vec4( col, 1.0 );\r\n      }\r\n\r\n         \r\n         \r\n      </script>\r\n      \r\n      \r\n      <script type=\"x-shader/x-vertex\" id=\"vertexshader\">\r\n         void main() {\r\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);\r\n\t\t\t}\r\n      </script>\r\n      \r\n      \r\n\t\t<script>\r\n       \r\n         var container;\r\n\t\t\tvar camera, scene, renderer;\r\n\r\n         \r\n         var uniforms;\r\n         var attributes;\r\n         var shaderMaterials = new Array();\r\n         var cube;\r\n         \r\n         var geometry;\r\n         var stats;\r\n         \r\n\r\n         \r\n         \r\n\t\t\tinit();\r\n\t\t\tanimate();\r\n         \r\n\t\t\tfunction init() {\r\n            \r\n               //init scene and camera\r\n            container = document.getElementById( 'canvas' );\r\n               \r\n            \r\n               \r\n            camera = new THREE.PerspectiveCamera( 5, window.innerWidth / window.innerHeight, 10, 8000 );\r\n            camera.position.z =  200;\r\n\r\n            camera.lookAt(new THREE.Vector3(0,0,0));\r\n               \r\n            scene = new THREE.Scene();\r\n            scene.fog = new THREE.Fog( 0x555555, 2000, 3500 );\r\n      \r\n            uniforms = {\r\n                    iResolution: {\ttype: 'v3', value: new THREE.Vector3( 300.0, 300.0, 1.0 )  },\r\n                    iGlobalTime: {\ttype: 'f', value: 1.0 },\r\n                    iChannelResolution: {\ttype: 'v3', value: new THREE.Vector3( 100.0, 100.0, 100.0 )   },\r\n                    iMouse: {\ttype: 'v3', value: new THREE.Vector3( 0.0, 1.0, 2.0 )},\r\n                    iDate:  {\ttype: 'v4', value: new THREE.Vector4( 0.0, 1.0, 2.0, 2.0 )  },\r\n                    iChannel0: {type: 't', value: THREE.ImageUtils.loadTexture( \"aTexture.png\" ) },\r\n                    iChannel1: {type: 't', value: THREE.ImageUtils.loadTexture( \"aTexture.png\" ) },\r\n                    iChannel2: {type: 't', value: THREE.ImageUtils.loadTexture( \"aTexture.png\" ) }\r\n                    };\r\n\r\n\r\n            var material = new THREE.ShaderMaterial( {\r\n                                                    uniforms: uniforms,\r\n                                                    vertexShader:   document.getElementById( 'vertexshader' ).textContent,\r\n                                                    fragmentShader: document.getElementById( 'fragmentshader' ).textContent\r\n            });\r\n      \r\n      \r\n      \r\n      \r\n            geometry = new THREE.PlaneGeometry(45, 45);\r\n            cube = new THREE.Mesh(geometry, material);\r\n            scene.add(cube);\r\n          \r\n            renderer = new THREE.WebGLRenderer( { antialias: true, alpha: false } );\r\n            renderer.setClearColor( scene.fog.color, 1 );\r\n            renderer.setSize( 800, 600);\r\n         \r\n            container.appendChild( renderer.domElement );\r\n            stats = new Stats();\r\n\t\t\t\tstats.domElement.style.position = 'absolute';\r\n\t\t\t\tstats.domElement.style.top = '0px';\r\n\t\t\t\tcontainer.appendChild( stats.domElement );\r\n       \r\n         \r\n      }\r\n      \r\n      function onWindowResize() {\r\n         \r\n         windowHalfX = window.innerWidth / 2;\r\n         windowHalfY = window.innerHeight / 2;\r\n         \r\n         camera.aspect = window.innerWidth / window.innerHeight;\r\n         camera.updateProjectionMatrix();\r\n         \r\n         renderer.setSize( window.innerWidth, window.innerHeight );\r\n         \r\n      }\r\n      \r\n\t\t\t//\r\n         \r\n      function animate() {\r\n         requestAnimationFrame( animate );\r\n      uniforms.iGlobalTime.value += 0.03;\r\n            uniforms.iGlobalTime.needsUpdate = true;\r\n         renderer.render( scene, camera );\r\n         stats.update();\r\n\r\n      }\r\n      \r\n         </script>\r\n      \r\n\t</body>\r\n</html>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}